# -*- coding: utf-8 -*-
"""HWATA1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16EZgCZ7P0Ow42anGvKWpPyFKrBug9wSC
"""

# HWATA 1: Streamlit App for Regularized Building Footprint Extraction

import streamlit as st
import geopandas as gpd
import rasterio
from rasterio.plot import reshape_as_image
import numpy as np
import torch
import torchvision.transforms as T
from segmentation_models_pytorch import Unet
import folium
from streamlit_folium import st_folium
import os
import tempfile
from shapely.geometry import Polygon
import zipfile
from buildingregulariser import BuildingRegulariser

# App title
st.set_page_config(layout="wide")
st.title("üè† HWATA: Building Footprint Extraction App")

# Load model
@st.cache_resource
def load_model():
    model = Unet(encoder_name="resnet34", in_channels=3, classes=1)
    model.load_state_dict(torch.load("pretrained_unet_building_segmentation.pth", map_location=torch.device('cpu')))
    model.eval()
    return model

model = load_model()

# Upload zip of imagery files
uploaded_file = st.file_uploader("üìÇ Upload a zipped 3-band GeoTIFF (e.g., RGB.tif inside a ZIP)", type=["zip"])

if uploaded_file:
    with tempfile.TemporaryDirectory() as tmpdir:
        zip_path = os.path.join(tmpdir, "input.zip")
        with open(zip_path, "wb") as f:
            f.write(uploaded_file.getbuffer())

        with zipfile.ZipFile(zip_path, 'r') as zip_ref:
            zip_ref.extractall(tmpdir)

        # Find the first tif file inside the zip
        tif_files = [os.path.join(tmpdir, f) for f in os.listdir(tmpdir) if f.endswith(".tif")]
        if not tif_files:
            st.error("No GeoTIFF (.tif) found in the uploaded ZIP.")
        else:
            tif_path = tif_files[0]
            with rasterio.open(tif_path) as src:
                image = src.read()
                profile = src.profile
                transform = src.transform
                crs = src.crs

            # Prepare image for model
            image_rgb = image[:3]  # Use first 3 bands (assumed RGB)
            image_rgb = reshape_as_image(image_rgb)
            transform_tensor = T.Compose([
                T.ToPILImage(),
                T.Resize((256, 256)),
                T.ToTensor()
            ])
            input_tensor = transform_tensor(image_rgb).unsqueeze(0)

            # Predict mask
            with torch.no_grad():
                pred_mask = model(input_tensor).squeeze().numpy()
            pred_mask = (pred_mask > 0.5).astype(np.uint8)

            # Resize mask to original dimensions
            pred_mask = np.array(T.Resize((image.shape[1], image.shape[2]))(T.ToPILImage()(pred_mask)))

            # Vectorize mask to polygons
            shapes = rasterio.features.shapes(pred_mask, transform=transform)
            polygons = [Polygon(geom["coordinates"][0]) for geom, value in shapes if value == 1]

            if not polygons:
                st.warning("No building footprints detected.")
            else:
                gdf_pred = gpd.GeoDataFrame(geometry=polygons, crs=crs)

                # Regularize using buildingregulariser
                gdf_pred = BuildingRegulariser().regularise(gdf_pred)

                # Reproject to EPSG:4326 for mapping
                gdf_pred = gdf_pred.to_crs(epsg=4326)

                # Show map
                st.subheader("üåê Preview Building Footprints")
                center = [gdf_pred.geometry.centroid.y.mean(), gdf_pred.geometry.centroid.x.mean()]
                m = folium.Map(location=center, zoom_start=18, tiles="https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}", attr="Google Satellite")

                folium.GeoJson(gdf_pred).add_to(m)
                st_folium(m, height=500, width=800)

                # Save and download
                with tempfile.NamedTemporaryFile(delete=False, suffix='.geojson') as tmp:
                    gdf_pred.to_file(tmp.name, driver='GeoJSON')
                    tmp_path = tmp.name

                st.subheader("üì• Download Footprints")
                with open(tmp_path, 'rb') as f:
                    st.download_button("Download GeoJSON", f, "building_footprints.geojson", "application/geo+json")