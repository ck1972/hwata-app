# -*- coding: utf-8 -*-
"""HWATA1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qIgb2CmPZ1REhRQa-ZyERt1oJbasfD96
"""

# HWATA 1: Streamlit App for Building Footprint Extraction (Demo)

import streamlit as st
import geopandas as gpd
import rasterio
import numpy as np
import torch
from torchvision.models.segmentation import deeplabv3_resnet101
from rasterio import features
from tempfile import NamedTemporaryFile
import os
import gdown

st.set_page_config(page_title="HWATA 1 – GeoAI Feature Extractor", layout="centered")
st.title("HWATA 1 – Building Footprint Extractor")
st.markdown("Upload a 30cm satellite or aerial image (GeoTIFF), and HWATA 1 will extract building footprints as GeoJSON.")

# Upload model and image
uploaded_img = st.file_uploader("Upload 30 cm Image (GeoTIFF)", type=["tif", "tiff"])

if uploaded_img:
    with NamedTemporaryFile(delete=False, suffix=".tif") as tmp_img:
        tmp_img.write(uploaded_img.read())
        tmp_img_path = tmp_img.name

    st.success("Image uploaded successfully. Running prediction...")

    # Load image
    with rasterio.open(tmp_img_path) as src:
        image = src.read()
        transform = src.transform
        height, width = src.height, src.width
        raster_crs = src.crs

    # ✅ Load model (download from Google Drive if missing, with error handling)
    model_path = "deeplabv3_resnet101.pth"
    if not os.path.exists(model_path):
        try:
            url = "https://drive.google.com/uc?id=1XxcKl_KH3IeBkj8svXulM0Nfhe7owxfr"
            gdown.download(url, model_path, quiet=False)
        except Exception as e:
            st.error("❌ Failed to download the model. Please ensure the file is shared publicly on Google Drive.")
            st.stop()

    model = deeplabv3_resnet101(weights=None, num_classes=2)
    model.load_state_dict(torch.load(model_path, map_location=torch.device("cpu")))
    model.eval()

    # Patch inference
    patch_size = 256
    full_pred_mask = np.zeros((height, width), dtype=np.uint8)

    with torch.no_grad():
        for i in range(0, height - patch_size + 1, patch_size):
            for j in range(0, width - patch_size + 1, patch_size):
                patch = image[:, i:i+patch_size, j:j+patch_size]
                patch_tensor = torch.tensor(patch, dtype=torch.float32).unsqueeze(0)
                output = model(patch_tensor)['out']
                pred_patch = torch.argmax(output, dim=1).squeeze().cpu().numpy()
                full_pred_mask[i:i+patch_size, j:j+patch_size] = pred_patch

    st.success("Prediction completed. Converting to GeoJSON...")

    results = (
        {'properties': {'raster_val': v}, 'geometry': s}
        for s, v in features.shapes(full_pred_mask.astype(np.int16), transform=transform)
        if v == 1
    )

    geoms = list(results)
    gdf_pred = gpd.GeoDataFrame.from_features(geoms, crs=raster_crs)

    geojson_save_path = "predicted_buildings.geojson"
    gdf_pred.to_file(geojson_save_path, driver="GeoJSON")

    st.success("Building footprints extracted.")
    with open(geojson_save_path, "rb") as f:
        st.download_button("Download GeoJSON", data=f, file_name="buildings.geojson")

    st.map(gdf_pred)

    os.remove(tmp_img_path)
    os.remove(geojson_save_path)
